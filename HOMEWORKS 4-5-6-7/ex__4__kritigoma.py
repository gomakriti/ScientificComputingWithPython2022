# -*- coding: utf-8 -*-
"""EX _4 _KRITIGOMA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jbAWA5aEKuLDwWU8CkYMprun4lsxjRSP
"""

import numpy as np
import numpy.random as npr
import matplotlib.pyplot as plt
import math
import timeit
############# QUES 1 ############

m_1= np.arange(12).reshape((3,4))
print(m_1)
column_mean = np.mean(m_1,axis=0)
row_mean = np.mean(m_1,axis=1)
print("Mean of the columns:",column_mean)
print("Mean of the rows:",row_mean)

###################### QUES  2 ##############
   
u = np.array([1, 3, 5, 7])
v = np.array([2, 4, 6, 8])

Op1=np.outer(u,v)
print(Op1)

Op2= np.zeros((4, 4))
for i in range(4):
        for j in range(4):
            Op2[i][j]=u[i]*v[j]
print(Op2)

Op3=u[:, None]*v
print(Op3)

########## QUES 3 ##########
#Create a 10 by 6 matrix of float random numbers, distributed between 0 and 3 according to a flat distribution.
#After creating the matrix, set all entries< 0.3 to zero using a mask.
Values=3*npr.rand(10, 6)
print(Values)
Values[Values < 0.3] = 0
print(Values)

############### QUES 4 ###################
 
array = np.linspace(0,2*math.pi,100)
print(array)

#extract every 10th element using slice notation
new_array = array[::10]
print("\n The elements that are in the 10th:\n",new_array)

#reverse the array using slice notation
reverse_new_array =new_array[::-1] 
print("\n Reversed elements that are in the 10th:\n",reverse_new_array)

#extract elements where the abs. difference between sin and cos functions evaluated for that element is <0.1
#print(reverse_new_array[0])
x_x = np.abs(np.sin(array)-np.cos(array)) < 0.1
print("\nExtracted elemens in array:","\n",array[x_x])

#Optional: make a plot showing the sin and cos functions and indicate where they are close
plt.scatter(array[x_x], np.sin(array[x_x]))
plt.plot(array, np.sin(array), array, np.cos(array))

############ QUES 5 #################
#Create a matrix that shows the 10 by 10 multiplication table.
#Find the trace of the matrix
#Extract the anti-diagonal matrix (this should be ```array([10, 18, 24, 28, 30, 30, 28, 24, 18, 10])```)
#Extract the diagonal offset by 1 upwards (this should be ```array([ 2,  6, 12, 20, 30, 42, 56, 72, 90])```)
    
mul= np.zeros((10, 10))
for i in range(10):
    for j in range(10):
            mul[i][j]=(i+1)*(j+1)

print(mul)
print(np.trace(mul))

mul_arr=np.matrix.flatten(mul)
print(mul_arr)
for i in range(10):
        print(mul_arr[9+i*9])
print("Diagonal offset by 1")

for j in range(9):
        print(mul_arr[1+j*11])

############ QUES 6 ###################33
mile=np.array([0, 198, 303, 736, 871, 1175, 1475, 1544, 1913, 2448])
print("in miles:",mile)
dis= np.abs(mile-mile[:, np.newaxis])
print("distances:","\n",dis)
d_km = dis*1.609344
print("distance array in km:","\n" ,d_km)

################ QUES 7 |####################
import timeit


def SieveOfEratosthenes(n):
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):

        if (prime[p] == True):

            for i in range(p ** 2, n + 1, p):
                prime[i] = False
        p += 1
    prime[0]= False
    prime[1]= False

    for p in range(n + 1):
        if prime[p]:
            print (p) 

starttime = timeit.default_timer()
SieveOfEratosthenes(1000)
print("The time difference is :", timeit.default_timer() - starttime)